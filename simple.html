<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Notes MVP</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 0;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: white;
            padding: 16px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }
        .editor-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .editor {
            width: 100%;
            height: 100%;
            padding: 20px;
            border: none;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            position: relative;
            z-index: 1;
            background: transparent;
            outline: none;
        }
        .editor:focus {
            outline: none;
        }
        .wikilink-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 2;
            color: transparent;
            white-space: pre-wrap;
            overflow: hidden;
            box-sizing: border-box;
        }
        .wikilink-highlight {
            background-color: rgba(0, 122, 204, 0.1);
            color: #007acc;
            cursor: pointer;
            text-decoration: underline;
            pointer-events: auto;
        }
        .footer {
            background: white;
            padding: 12px 16px;
            border-top: 1px solid #ddd;
            font-size: 12px;
            color: #666;
            flex-shrink: 0;
        }
        #searchResults {
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <div style="display: flex; gap: 12px; align-items: center;">
            <button id="backButton" onclick="goBackToDailyNote()" style="display: none; padding: 6px 12px; border: 1px solid #ccc; border-radius: 4px; background: white; font-size: 12px; cursor: pointer;">‚Üê Back</button>
            <h1 id="filename" style="margin: 0; font-size: 18px;">üìù Loading...</h1>
        </div>
        <div style="display: flex; gap: 8px; align-items: center;">
            <input type="text" id="searchInput" placeholder="Search notes..." style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;" />
            <button onclick="openMasterTasks()" style="padding: 6px 12px; border: 1px solid #007acc; border-radius: 4px; background: #007acc; color: white; font-size: 12px; cursor: pointer;">üìã Tasks</button>
            <div id="status">Initializing...</div>
        </div>
    </div>

    <div id="searchResults" style="display: none; background: white; border-bottom: 1px solid #ddd; max-height: 200px; overflow-y: auto; padding: 8px;"></div>

    <div class="editor-container">
        <textarea id="editor" class="editor" placeholder="Loading daily note..."></textarea>
        <div id="wikilinkOverlay" class="wikilink-overlay"></div>
    </div>

    <div class="footer">
        <div id="backlinks" style="margin-bottom: 8px; display: none; position: relative;">
            <strong>üìé Linked from:</strong>
            <span id="backlinksList" style="color: transparent; position: relative; z-index: 1;"></span>
            <div id="backlinksOverlay" style="position: absolute; top: 0; left: 115px; width: calc(100% - 115px); height: 100%; pointer-events: none; z-index: 2;"></div>
        </div>
        <strong>‚úÖ Simple note editor working!</strong><br>
        Cmd/Ctrl+Enter to cycle tasks ‚Ä¢ Tab/Shift+Tab to indent/outdent ‚Ä¢ Cmd/Ctrl+Click [[wikilinks]] to navigate
    </div>

    <script>
        console.log('üöÄ Simple editor loading...');

        const editor = document.getElementById('editor');
        const wikilinkOverlay = document.getElementById('wikilinkOverlay');
        const status = document.getElementById('status');
        const filename = document.getElementById('filename');
        const backButton = document.getElementById('backButton');

        // Get IPC renderer if available
        const { ipcRenderer } = window.require?.('electron') ?? { ipcRenderer: null };

        let currentFilePath = null;
        let dailyNotePath = null; // Track the daily note path
        let hasUnsavedChanges = false;
        let rawContent = ''; // Store the raw content with ID markers

        // Helper function to hide/show ID markers
        function hideIdMarkers(content) {
            return content.replace(/\s*<!--\s*\{id:\s*[0-9a-fA-F-]{36}\}\s*-->/g, '');
        }

        function restoreIdMarkers(displayContent, originalContent) {
            // Simple approach: if we're editing, work with display content
            // When saving, the indexer will add missing ID markers back
            return displayContent;
        }

        // Wikilink overlay functionality
        function updateWikilinkOverlay() {
            const content = editor.value;
            const wikilinkPattern = /\[\[([^\]]+)\]\]/g;

            // Create a copy of the content with wikilinks highlighted
            let overlayContent = content;
            let offset = 0;
            let match;

            // Reset pattern to start from beginning
            wikilinkPattern.lastIndex = 0;

            const matches = [];
            while ((match = wikilinkPattern.exec(content)) !== null) {
                matches.push({
                    start: match.index,
                    end: match.index + match[0].length,
                    target: match[1],
                    fullMatch: match[0]
                });
            }

            // Build overlay content with spans for wikilinks
            if (matches.length > 0) {
                let result = '';
                let lastIndex = 0;

                matches.forEach(match => {
                    // Add text before the wikilink
                    result += content.slice(lastIndex, match.start);

                    // Add the wikilink as a clickable span (with Cmd/Ctrl+Click)
                    result += `<span class="wikilink-highlight" data-target="${match.target}" onmousedown="handleWikilinkMouseDown(event, '${match.target}')">${match.fullMatch}</span>`;

                    lastIndex = match.end;
                });

                // Add remaining text
                result += content.slice(lastIndex);
                overlayContent = result;
            }

            wikilinkOverlay.innerHTML = overlayContent;

            // Sync scroll position
            wikilinkOverlay.scrollTop = editor.scrollTop;
            wikilinkOverlay.scrollLeft = editor.scrollLeft;
        }

        // Handle wikilink mouse down from overlay (requires Cmd/Ctrl+Click)
        function handleWikilinkMouseDown(event, target) {
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                console.log('üîó Cmd/Ctrl+clicked on wikilink:', target);
                navigateToWikilink(target);
            }
        }

        // Update backlink highlights to make them clickable
        function updateBacklinkHighlights() {
            const backlinksOverlay = document.getElementById('backlinksOverlay');
            const backlinksList = document.getElementById('backlinksList');

            if (!backlinksOverlay || !backlinksList) return;

            const content = backlinksList.textContent || '';
            const wikilinkPattern = /\[\[([^\]]+)\]\]/g;

            // Create a copy of the content with wikilinks highlighted
            let overlayContent = content;
            let match;

            // Reset pattern to start from beginning
            wikilinkPattern.lastIndex = 0;

            const matches = [];
            while ((match = wikilinkPattern.exec(content)) !== null) {
                matches.push({
                    start: match.index,
                    end: match.index + match[0].length,
                    target: match[1],
                    fullMatch: match[0]
                });
            }

            // Build overlay content with spans for wikilinks
            if (matches.length > 0) {
                let result = '';
                let lastIndex = 0;

                matches.forEach(match => {
                    // Add text before the wikilink
                    result += content.slice(lastIndex, match.start);

                    // Add the wikilink as a clickable span
                    result += `<span class="wikilink-highlight" data-target="${match.target}" onmousedown="handleWikilinkMouseDown(event, '${match.target}')" style="pointer-events: auto;">${match.fullMatch}</span>`;

                    lastIndex = match.end;
                });

                // Add remaining text
                result += content.slice(lastIndex);
                overlayContent = result;
            }

            backlinksOverlay.innerHTML = overlayContent;
        }

        // Initialize app - load daily note
        async function initializeApp() {
            try {
                if (!ipcRenderer) {
                    // Fallback mode - no IPC available
                    status.textContent = '‚ö†Ô∏è No file system access';
                    filename.textContent = 'üìù demo-note.md';
                    editor.value = '# Demo Note\n\n- [ ] Sample task\n- Regular bullet point\n- [ ] (Doing) Task in progress\n- [x] Completed task';
                    return;
                }

                status.textContent = 'Loading daily note...';
                console.log('üìÖ Requesting daily note...');

                // Get today's daily note path
                currentFilePath = await ipcRenderer.invoke('vault.ensureDailyNote');
                dailyNotePath = currentFilePath; // Store the daily note path
                console.log('üìÖ Daily note path:', currentFilePath);

                // Update filename display
                const fileName = currentFilePath.split('/').pop();
                filename.textContent = `üìù ${fileName}`;

                // Hide back button for daily note
                backButton.style.display = 'none';

                // Load file content
                const content = await ipcRenderer.invoke('fs.read', currentFilePath);
                console.log('üìÑ Loaded content length:', content.length);

                rawContent = content; // Store raw content with ID markers
                editor.value = hideIdMarkers(content); // Display clean content
                updateWikilinkOverlay(); // Update wikilink highlights
                status.textContent = '‚úÖ Ready';
                hasUnsavedChanges = false;

                // Load backlinks for the current note
                await loadBacklinks(currentFilePath);

            } catch (error) {
                console.error('‚ùå Failed to load daily note:', error);
                status.textContent = '‚ùå Failed to load note';
                filename.textContent = 'üìù Error';
            }
        }

        // Save current content to file
        async function saveFile() {
            if (!ipcRenderer || !currentFilePath) {
                console.log('üíæ No file system access - just showing status');
                return;
            }

            try {
                status.textContent = 'Saving...';
                // Save the clean content - indexer will add ID markers back
                await ipcRenderer.invoke('fs.write', currentFilePath, editor.value);
                status.textContent = 'üíæ Saved';
                hasUnsavedChanges = false;
                console.log('üíæ File saved successfully');

                setTimeout(() => {
                    if (status.textContent === 'üíæ Saved') {
                        status.textContent = '';
                    }
                }, 2000);

            } catch (error) {
                console.error('‚ùå Save failed:', error);
                status.textContent = '‚ùå Save failed';
            }
        }

        // Task cycling function
        function cycleTaskStateInTextLine(line) {
            if (line.match(/^(\s*)-\s+\[ \]\s+(?!\(Doing\))/)) {
                return line.replace(/^(\s*-\s+\[ \])(\s+)/, '$1 (Doing)$2');
            }
            if (line.match(/^(\s*)-\s+\[ \]\s+\(Doing\)/)) {
                return line.replace(/^(\s*-\s+)\[ \]\s+\(Doing\)(\s+)/, '$1[x]$2');
            }
            if (line.match(/^(\s*)-\s+\[x\]/)) {
                return line.replace(/^(\s*-\s+)\[x\](\s+)/, '$1[ ]$2');
            }
            if (line.match(/^(\s*)-\s+/)) {
                return line.replace(/^(\s*-\s+)/, '$1[ ] ');
            }
            return `- [ ] ${line}`;
        }

        // Keyboard handling
        editor.addEventListener('keydown', function(e) {
            if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                e.preventDefault();
                console.log('üîÑ Cycling task state...');

                const pos = editor.selectionStart;
                const value = editor.value;
                const lineStart = value.lastIndexOf('\n', pos - 1) + 1;
                const lineEnd = value.indexOf('\n', pos);
                const endPos = lineEnd === -1 ? value.length : lineEnd;
                const line = value.slice(lineStart, endPos);
                const newLine = cycleTaskStateInTextLine(line);

                const newValue = value.slice(0, lineStart) + newLine + value.slice(endPos);
                editor.value = newValue;

                // Calculate new cursor position to maintain relative position
                const lengthDiff = newLine.length - line.length;
                const newPos = pos + lengthDiff;
                editor.setSelectionRange(newPos, newPos);

                status.textContent = '‚úÖ Task cycled';
                setTimeout(() => status.textContent = '', 1500);
            }

            if (e.key === 'Tab') {
                e.preventDefault();
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const value = editor.value;

                if (e.shiftKey) {
                    // Outdenting
                    console.log('üîç Outdenting - start:', start, 'end:', end);

                    // If no selection, work with the current line
                    let lineStart, lineEnd;
                    if (start === end) {
                        // No selection - work with current line
                        lineStart = value.lastIndexOf('\n', start - 1) + 1;
                        lineEnd = value.indexOf('\n', start);
                        if (lineEnd === -1) lineEnd = value.length;
                    } else {
                        // Selection exists - work with all selected lines
                        lineStart = value.lastIndexOf('\n', start - 1) + 1;
                        lineEnd = value.indexOf('\n', end - 1);
                        if (lineEnd === -1) lineEnd = value.length;
                    }

                    const selectedText = value.slice(lineStart, lineEnd);
                    console.log('üîç Selected text for outdenting:', JSON.stringify(selectedText));

                    const lines = selectedText.split('\n');
                    const transformedLines = lines.map(line => {
                        if (line.startsWith('  ')) {
                            console.log('üîç Removing 2 spaces from:', JSON.stringify(line));
                            return line.slice(2);
                        } else if (line.startsWith(' ')) {
                            console.log('üîç Removing 1 space from:', JSON.stringify(line));
                            return line.slice(1);
                        }
                        console.log('üîç No spaces to remove from:', JSON.stringify(line));
                        return line;
                    });

                    const transformed = transformedLines.join('\n');
                    console.log('üîç Transformed text:', JSON.stringify(transformed));

                    const before = value.slice(0, lineStart);
                    const after = value.slice(lineEnd);
                    const newValue = before + transformed + after;

                    editor.value = newValue;

                    // Maintain cursor position
                    const lengthDiff = selectedText.length - transformed.length;
                    const newStart = Math.max(lineStart, start - lengthDiff);
                    const newEnd = Math.max(lineStart, end - lengthDiff);

                    editor.setSelectionRange(newStart, start === end ? newStart : newEnd);

                } else {
                    // Indenting (existing logic)
                    const before = value.slice(0, start);
                    const sel = value.slice(start, end);
                    const after = value.slice(end);

                    const transformed = sel.replace(/^/gm, '  ');
                    editor.value = before + transformed + after;
                    editor.selectionStart = start + 2;
                    editor.selectionEnd = end + (transformed.length - sel.length);
                }

                status.textContent = e.shiftKey ? '‚¨ÖÔ∏è Outdented' : '‚û°Ô∏è Indented';
                setTimeout(() => status.textContent = '', 1500);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        let searchTimeout;

        async function performSearch(query) {
            if (!query.trim() || !ipcRenderer) {
                searchResults.style.display = 'none';
                return;
            }

            try {
                const results = await ipcRenderer.invoke('search.blocks', query);
                console.log('üîç Search results:', results);

                if (results.length === 0) {
                    searchResults.innerHTML = '<div style="color: #666; font-size: 12px;">No results found</div>';
                } else {
                    searchResults.innerHTML = results.map(result => {
                        const text = result.text || '';
                        const preview = text.length > 100 ? text.substring(0, 100) + '...' : text;
                        return `
                        <div style="cursor: pointer; padding: 4px; border-radius: 4px; margin: 2px 0; font-size: 12px; border-left: 3px solid #007acc;"
                             onclick="console.log('Result clicked:', '${result.block_id}')">
                            <div style="font-weight: bold; color: #333;">${result.note_id || 'Unknown note'}</div>
                            <div style="color: #666;">${preview || 'No content'}</div>
                        </div>
                        `;
                    }).join('');
                }
                searchResults.style.display = 'block';
            } catch (error) {
                console.error('‚ùå Search failed:', error);
                searchResults.innerHTML = '<div style="color: #cc0000; font-size: 12px;">Search failed</div>';
                searchResults.style.display = 'block';
            }
        }

        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = searchInput.value;

            if (!query.trim()) {
                searchResults.style.display = 'none';
                return;
            }

            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        });

        // Hide search results when clicking elsewhere
        document.addEventListener('click', function(e) {
            if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                searchResults.style.display = 'none';
            }
        });

        // Auto save with real file operations
        let saveTimeout;
        editor.addEventListener('input', function() {
            hasUnsavedChanges = true;
            updateWikilinkOverlay(); // Update highlights as user types
            clearTimeout(saveTimeout);

            // Auto-save after 1 second of no typing
            saveTimeout = setTimeout(() => {
                saveFile();
            }, 1000);
        });

        // Keep overlay in sync when scrolling
        editor.addEventListener('scroll', function() {
            wikilinkOverlay.scrollTop = editor.scrollTop;
            wikilinkOverlay.scrollLeft = editor.scrollLeft;
        });

        // Wikilink navigation functionality
        async function navigateToWikilink(linkTarget) {
            if (!ipcRenderer) {
                console.log('üîó No IPC - cannot navigate to:', linkTarget);
                return;
            }

            try {
                status.textContent = 'Loading note...';
                console.log('üîó Navigating to wikilink:', linkTarget);

                // Get the note path (creates if doesn't exist)
                const notePath = await ipcRenderer.invoke('notes.navigate', linkTarget);
                console.log('üìÅ Note path:', notePath);

                // Load the note content
                const content = await ipcRenderer.invoke('fs.read', notePath);
                console.log('üìÑ Loaded note content length:', content.length);

                // Update UI
                currentFilePath = notePath;
                const fileName = notePath.split('/').pop();
                filename.textContent = `üìù ${fileName}`;
                rawContent = content; // Store raw content
                editor.value = hideIdMarkers(content); // Display clean content
                updateWikilinkOverlay(); // Update wikilink highlights
                status.textContent = '‚úÖ Note loaded';
                hasUnsavedChanges = false;

                // Show back button if not on daily note
                if (currentFilePath !== dailyNotePath) {
                    backButton.style.display = 'block';
                } else {
                    backButton.style.display = 'none';
                }

                // Load backlinks for the new note
                await loadBacklinks(currentFilePath);

                // Clear any search results
                searchResults.style.display = 'none';
                searchInput.value = '';

            } catch (error) {
                console.error('‚ùå Failed to navigate to wikilink:', error);
                status.textContent = '‚ùå Navigation failed';
            }
        }

        // The old Ctrl+Click handler has been replaced by the overlay approach

        // Backlinks functionality
        const backlinksDiv = document.getElementById('backlinks');
        const backlinksList = document.getElementById('backlinksList');

        async function loadBacklinks(notePath) {
            if (!ipcRenderer || !notePath) {
                backlinksDiv.style.display = 'none';
                return;
            }

            try {
                console.log('üîó Loading backlinks for:', notePath);
                const backlinks = await ipcRenderer.invoke('notes.backlinks', notePath);
                console.log('üîó Backlinks received:', backlinks);

                if (backlinks && backlinks.length > 0) {
                    // Create wikilink-style backlink entries that work with Cmd+Click
                    const backlinkItems = backlinks.map(backlink => {
                        const fileName = backlink.title || backlink.path.split('/').pop();
                        return `[[${fileName}]]`;
                    }).join(' ‚Ä¢ ');

                    // Set the backlinks content and update the overlay to make them clickable
                    backlinksList.innerHTML = backlinkItems;

                    // Apply wikilink highlighting to backlinks
                    updateBacklinkHighlights();

                    backlinksDiv.style.display = 'block';
                } else {
                    backlinksDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('‚ùå Failed to load backlinks:', error);
                backlinksDiv.style.display = 'none';
            }
        }

        // Go back to daily note
        async function goBackToDailyNote() {
            if (!dailyNotePath) {
                console.log('‚ö†Ô∏è No daily note path stored');
                return;
            }
            console.log('üîô Going back to daily note:', dailyNotePath);
            navigateToWikilink(dailyNotePath.split('/').pop().replace('.md', ''));
        }

        // Open Master Tasks view
        function openMasterTasks() {
            console.log('üìã Opening Master Tasks view...');
            window.location.href = 'tasks.html';
        }

        // Check if we need to load a specific note (from Master Tasks navigation)
        function checkLoadNote() {
            const noteToLoad = localStorage.getItem('loadNote');
            if (noteToLoad) {
                localStorage.removeItem('loadNote');
                console.log('üìù Loading note from Master Tasks:', noteToLoad);
                navigateToWikilink(noteToLoad);
            }
        }

        // Initialize the app when page loads
        window.addEventListener('load', () => {
            console.log('üöÄ Initializing app...');
            initializeApp().then(() => {
                checkLoadNote();
            });
        });

        console.log('‚úÖ Simple editor script ready!');
    </script>
</body>
</html>